---
title: TCP
order: 2
---

# TCP

相信各位已经看过不少关于 TCP 协议的文章了，这里我们换种方式，以 **TCP 扮演的角色** 切入，给大家讲一下关于 TCP 你需要了解的一些东西。

## TCP 扮演的角色

TCP 协议在互联网中其实扮演了一个 **可靠和完整的数据传输者** 的角色，为什么？

通过 [OSI](https://en.wikipedia.org/wiki/OSI_model) 七层模型，我们知道互联网其实是由一整套协议构成的，

![image.png](https://i.loli.net/2020/07/21/dIPzXkMh25j9bOx.png)

而我们今天的主角，TCP 协议位于传输层，所以我们叫它 “数据传输者” 没啥问题。在 [上一篇](https://campcc.github.io/repository/basics/osi/udp) 文章中，我们介绍了在传输层还有另一个扮演类似角色的协议，**UDP**，我们知道 UDP 是高效但不可靠的，所以作为补充，TCP 协议从一开始就被设计为 **完整和可靠的**。

**你可能会有疑惑为什么我们需要这样一个可靠的协议？**

这个问题还得从他的邻居说起。回到上图，我们发现 TCP 协议是以太网协议 (Ethernet) 和 IP 协议的上层协议，以太网协议和 IP 协议都干了什么事？

最底层的以太网协议规定了电子信号如何组成数据包（packet），所以基于以太网协议，我们可以实现局域网内的 **点对点通信**，

![image.png](https://i.loli.net/2020/07/21/z1VZyB7cpliTM9J.png)

但是以太网协议只能解决局域网内部的通信，局域网之间想要建立连接怎么办？**交给 IP 协议**。

IP 协议定义了一套地址规则，也就是我们说的 IP 地址，同时实现了 **路由** 的功能，允许某个局域网内的主机 A 想另一个局域网的主机 B 发送消息。有了 IP 协议，局域网之间互通就很简单了，我们只需要通过路由器（路由器就是 IP 协议的实现），在对应的网口插上网线，就可以实现数据转发。

而路由的原理其实很简单，路由器的内部维护了一张路由表，规定了每段 IP 地址的出口，也就是我们数据包到达的目的地，通过路由表，我们就可以知道数据包应该发送到哪个网口了。什么？你不知道路由器长啥样？

![image.png](https://i.loli.net/2020/07/22/dgSasO48mEGjtNz.png)

( 图片说明：路由器背后有很多网口，接入网线后，每一个网口就对应路由表内的一个数据包出口 )

IP 协议是一个地址协议，可以实现数据包的转发，但是数据通信远不止转发包这么简单，试想一下，

- 如果路由器缓存满了导致丢包了，该如何重发丢失的包？
- 怎么样保证数据包传输的完整性？
- 网络条件差的情况下，怎么样控制发包的速率，减少丢包？
- ... ...

所以，我们确实需要这么一个协议，来解决丢包的问题，**保证数据通信的可靠和完整**。而这个协议，就是 **TCP 协议**。

## TCP 的头部信息

一个数据包（报文段）分为头部和数据两个部分，以太网数据包（packet）的大小是固定的 1522 字节（其中 1500 字节是负载，22 字节是头部信息），而 IP，TCP 数据包都是以太网数据包负载的一部分。具体来说，IP 数据包在以太网数据包负载里面，TCP 数据包在 IP 数据包的负载里面。

为了保证数据通信的可靠和完整性，TCP 在头部信息中加入了一系列的控制字段，所以 TCP 的头部信息要复杂的多，这也导致了 TCP 负载实际为 1400 字节左右。

因此，一条 1500 字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。

![image.png](https://i.loli.net/2020/07/30/nRft64S2LwduFZi.png)

接下来我们来详细了解下 TCP 头部信息中的几个重要字段。

### SEQ

我们知道一个 TCP 包负载 1400 字节，那么如果要一次性发送大量数据，就必须分成多个包。（比如，一个 1MB 的文件，需要约 710 多个包）。所以在发包前，TCP 协议会为每个包进行编号，以便接收的一方按照顺序还原，Sequence number 就是包的编号。

SEQ 是很有必要的，它保证了 **TCP 传输的报文都是有序的，而且万一发生了丢包，对端也可以知道丢失的是哪一个包**。

**TCP 包是如何编号的 ？**

首先第一个包的 sequence number 是一个随机数，假定这个包的负载长度是 100 字节，那么可以推算出下一个包的编号应该是 101，也就是说，每个数据包都可以得到两个编号：**自身的编号，以及下一个包的编号**。接收方由此知道，应该按照什么顺序将它们还原成原始文件。

### ACK

默认情况下，接收方每接收两个数据包，就要发送一个确认消息，确认的英文为 `acknowledgement`，所以这个确认消息就简称为 ACK。

具体来说，ACK 携带了两个信息，

- 下一个数据包的编号
- 接收窗口的剩余容量

这两个信息与 TCP 的**慢启动机制**息息相关，我们会在稍后详细地介绍。

### Window Size

窗口大小，表示还能接收多少字节的数据，用于流量控制。

### 标识符

头部信息中还包含一些控制字段，也叫标识符，它们的取值为 0 或 1，我们选一些比较常见的进行了解，

- URG=1 时，表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文
- ACK=1 时，表示确认号字段有效，TCP 规定在连接建立后传送的所有报文段都必须把 ACK 置为 1
- PSH=1 时，表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交
- RST=1 时，表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求
- SYN=1 时，表示当前报文段是一个建立连接的请求报文或者同意建立连接的应答报文
- FIN=1 时，表示当前报文是一个释放连接的请求报文或者同意释放连接的应答报文

## 面向连接

我们之前讲通信技术大致可以分为三类：**面向连接的电路交换，面向连接的包交换，以及无连接的包交换**。

TCP 在这里使用的是**面向连接的包交换**，为什么？因为我们需要实现的是一个可靠的通信协议。

面向连接意味着通信开始前，双方需要先建立连接。

### RTT

RTT 是一个性能指标，表示**发送端发送数据到接收到对端数据所需的往返时间**。

### TCB

每一个 TCP 连接都会创建 TCB（Transmit Control Block，传输控制模块），用于记录 TCP 协议运行过程中的变量。

### 建立连接

TCP 是一个全双工的协议，在建立连接后双方都能发送和接收数据，其中，主动发起请求的一端为客户端，被动接受的一端为服务端。

建立一个 TCP 连接需要三次握手，需要客户端和服务器总共发送 3 个包。

![image.png](https://i.loli.net/2020/07/22/vgH5bCKjsmuNTMt.png)

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。

- **第一次握手**，客户端将标志位 SYN 置为 1，随机产生一个 sequence number（假定 seq=j），并将该数据包发送至服务端，发送完成后客户端进入 SYN-SENT 状态，等待服务端确认。
- **第二次握手**，服务端收到连接请求的数据包后，如果同意连接，会将标志位 SYN 和 ACK 都置为 1，随机产生一个 sequence number（假定 seq=k），连同确认消息（ack=J+1）一起发送一个应答，发送完成后进入 SYN-RECEIVED 状态。
- **第三次握手**，客户端接收到数据包后，检查确认消息 ack 是否为 j+1，标志位 ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=k+1，并将该数据包发送给服务器端，然后服务器端检查 ack 是否为 k+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态。

**为什么需要第三次应答？**

为了**防止失效的连接请求报文段被服务端接收**，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。

PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

### 断开连接

断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。

![image.png](https://i.loli.net/2020/07/22/WP8RYONUaTpKZ9v.gif)

中断连接端可以是客户端，也可以是服务器端，我们以客户端发起断开连接为例，详细了解下 4 次挥手的过程，起初两端都为 ESTABLISHED 状态，

- **第一次挥手**，客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，发送完成后进入 FIN_WAIT_1 状态，此时服务器端如果还有数据没有发送完成，会继续发送数据。
- **第二次挥手**，服务器端收到 FIN 后，会先发送确认消息 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。
- **第三次挥手**，服务器端确定数据已发送完成后，会向客户端发送再次发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了，发送后服务器端进入 LAST_ACK 状态。
- **第四次挥手**，客户端收到 FIN=N 的报文后，会发送确认消息 ack=N+1 后进入 TIME_WAIT 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，如果该时间段内没有服务器端的重发请求的话，就进入 CLOSED 状态，服务器端收到 ACK 后，进入 CLOSED 状态。

**为什么需要四次挥手，而不是三次？**

因为第一次挥手时，服务端可能还有数据没有发送完成，所以服务端会发两次 FIN，第一次用于确认收到关闭连接请求报文，第二次用于断开连接。

**为什么客户端要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**

为了保证服务端能够收到客户端的确认消息。如果客户端发完确认消息后直接进入 CLOSED 状态，因为网络问题一直没有到达，那么会造成服务端不能正常关闭。

## ARQ

ARQ 协议就是超时重传机制。超时重传主要用来解决如下几种场景：**丢包，包错误，对端的 ACK 超时，ACK 丢失**。

我们之前说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。

比如，现在收到了 4 号包，但是没有收到 5 号包。ACK 就会记录，期待收到 5 号包。过了一段时间，5 号包收到了，那么下一轮 ACK 会更新编号。如果 5 号包还是没收到，但是收到了 6 号包或 7 号包，那么 ACK 里面的编号不会变化，总是显示 5 号包。这会导致大量重复内容的 ACK。

如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即 5 号包遗失了，从而再次发送这个包。

实现这种机制最简单的办法就是，**定时器**，ARQ 协议提供了 **停止等待 ARQ** 和 **连续 ARQ** 两种方式。

### 停止等待 ARQ

这种方式下，只要客户端向服务端发送一段报文，就会停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。

如果丢包，超过定时器设定的时间就会再次发送丢失的包直到对端响应，所以每次都需要备份发送的数据。但是即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题，这时候对端会抛弃该报文并等待客户端重传。

PS：一般定时器设定的时间都会大于一个 RTT 的平均时间，ACK 超时或丢失的情况与丢包的处理方式类似。

**这个协议的缺点就是传输效率低，即使在良好的网络环境下，每次发送报文都得等待对端的 ACK**。

### 连续 ARQ

连续 ARQ 针对上述方案做了一个改进，发送端新增了一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，以减少 ACK 等待的时间。也就是说，接收端会持续不断收到报文，最后进行累计确认。

**这个协议的缺点是如果中间丢包了，累计确认消息只能回复第一次丢包后的 ACK，这样会造成发送端重复发送数据**。

PS：累计确认的缺点可以通过 Sack 解决，Sack 是一个 TCP 的选项，来允许 TCP 单独确认非连续的片段，用于告知真正丢失的包，只重传丢失的片段。

## 流量控制

之前介绍 TCP 协议中有一个重要的字段叫 Window Size，用于流量控制，它表示了当前窗口还能接收多少字节的数据。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。

![image.png](https://i.loli.net/2020/08/27/P9RpEvjJeDzAlXr.png)

实现流量控制的方案叫滑动窗口。

### 滑动窗口

所谓滑动，就是**重设发送窗口的大小**。发送端窗口是由接收窗口剩余大小决定的，接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

当发送端接收到应答报文后，会随之将窗口进行滑动。

![image.png](https://i.loli.net/2020/08/27/ynW4sJHIAej92Uh.png)

接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，实现流量控制。

### Zero 窗口

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。

## 拥塞控制

拥塞控制是 TCP 中比较复杂的机制，它包括了四个算法：**慢启动，拥塞避免，快速重传和快速恢复**。

### 慢启动

服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。

最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。

所以慢启动机制就是：开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

Linux 内核里面设定了（常量`TCP_INIT_CWND`），刚开始通信的时候，发送方一次性发送 10 个数据包，即"发送窗口"的大小为 10。然后停下来，等待接收方的确认，再继续发送。

通过 ACK，SEQ 和 Window Size，发送方就可以推测出接收方大概的接收速度，从而降低或增加发送速率。

PS：即使对于带宽很大、线路很好的连接，TCP 也总是从 10 个数据包开始慢慢试，过一段时间以后，才达到最高的传输速率。

### 拥塞避免

慢启动算法中，如果不丢包，会加快发送速率。具体来说，每过一个 RTT 就会将窗口大小乘以二，但是这种指数级的增长肯定是不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。

这个算法非常简单，如果超过阈值，每过一个 RTT 发送窗口大小只会增加 1，这样能够避免指数级增长导致的网络拥塞，慢慢将窗口大小调整到最佳值。

### 快速重传

介绍快速重传之前，先简单了解下快速恢复：快速恢复就是重发对端需要的包，一旦收到一个新的 ACK 答复就退出。

快速重传针对的场景为：接收端接收到的报文失序的情况。这时候，在没有 Sack 的情况下，接收端只会回复最后一个顺序正确的报文序号，也就是我们之前说的 ACK 重复的情况。

如果收到三个重复的 ACK，就会启动快速重传，不用等待定时器超时重发了。

具体算法分为两种：

**TCP Taho**

- 阈值大小减半
- 窗口设为 1 MSS（一个分段的最大数据量）
- 重新开始慢启动

**TCP Reno**

- 窗口大小减半
- 阈值设为当前窗口
- 进入快速恢复阶段
- 使用拥塞避免算法
