---
title: HTTP
order: 3
---

# HTTP

HTTP 是基于 TCP/IP 的应用层协议，是 Web 上进行数据交换的基础，主要规定了客户端与服务器之间的通信格式，默认使用 80 端口。

## 发展历史

### HTTP/0.9

1991 年，第一个 HTTP 版本诞生，只有一个命令 `GET`，请求只有一个请求行，没有头部和实体，响应只能是 HTML 格式的字符串。

```html
GET / index.html
```

服务器发送完响应后，就会关闭 TCP 连接。

```html
<html>
  <body>
    Hello World
  </body>
</html>
```

### HTTP/1.0

1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。

- 支持任意格式的内容传输，包括文字，图像、视频、二进制文件等
- 新增 POST，HEAD 命令丰富了浏览器与服务器的交互手段
- 请求和响应格式变更，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据
- 新增状态码（HTTP Status Code），多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

这个版本的 HTTP 已经可以满足大部分的交互需求，但是仍然存在以下缺点，

- 每个 TCP 连接只能发送一个请求。服务端发送数据完毕后，连接就关闭，如果还要请求其他资源，就必须再新建一个连接
- 性能较差，根本原因是 TCP 连接的新建成本很高（三次握手，慢启动机制），而且无法复用

### HTTP/1.1

为了解决上述问题，大约半年后，1997 年 1 月，HTTP/1.1 版本发布，它进一步完善了 HTTP 协议，一直用到了 20 多年后的今天，直到现在还是最流行的版本。HTTP/1.1 做了如下优化，

- 引入持久连接（persistent connection），实现了 TCP 连接复用。TCP 连接默认不关闭，不用显式地声明 Connection，可以被多个请求复用。
- 新增管道机制（pipelining），改进了 HTTP 协议的效率。支持一个 TCP 连接里，同时发送多个请求
- 新增分块传输编码，允许使用流模式发送块数据
- 新增 Host 字段，提供虚拟主机支持
- 支持更多的动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE

虽然这个版本允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，这会导致"队头堵塞"（Head-of-line blocking）问题。因为服务器只有处理完一个回应，才会进行下一个回应，要是前面的回应特别慢，后面就会有许多请求排队等着。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。显然如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。

### HTTP/2

2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

HTTP/2 基于谷歌开发的 SPDY 协议，解决 HTTP/1.1 效率不高等诸多问题。

- 引入新的编码机制，支持二进制传输
- 引入帧（frame）和流（stream）概念，解决队头阻塞问题，实现多路复用。一个 TCP 连接中允许存在多个流，也就是可以发送多个请求。
- 支持 Header 压缩
- 支持服务端推送

简单了解了 HTTP 的发展历史后，我们来深入看下当前最流行的 HTTP/1.1 和大幅提高 Web 性能的 HTTP/2。

## HTTP/1.1

### 请求格式

下面是一个 1.1 版本请求的例子。

```html
GET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent:
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */*
```

第一行是请求行，请求行必须在尾部添加协议版本，后面就是多行头信息，描述客户端的情况。下面是一个响应的例子。

```html
HTTP/1.1 200 OK Server: nginx/1.16.1 Date: Fri, 28 Aug 2020 06:09:58 GMT
Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996
15:55:28 GMT Transfer-Encoding: chunked Connection: keep-alive

<html>
  <body>
    Hello World
  </body>
</html>
```

响应格式为：**头信息 + 一个空行（\r\n） + 响应数据**。其中，头信息的第一行叫响应行，包括协议版本，状态码，状态描述。

### 常见状态码

#### 2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

#### 3XX 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

#### 4XX 客户端错误

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

#### 5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### Post 和 Get 区别

先引入副作用和幂等的概念。

副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

在技术上说：

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body 来传输比 Get 更多的数据，Get 没有这个技术
- URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

### HTTP 缓存

#### 缓存规则

缓存按类型可以分为：客户端缓存，服务端缓存，代理服务器缓存，HTTP 缓存属于客户端缓存。

按缓存规则，HTTP 缓存又可以细分为：**强缓存和协商缓存**。

#### 强缓存

如果浏览器的缓存数据库中已经存在请求数据时，客户端直接从缓存数据库中获取数据，没有时才从服务端获取。

对于强缓存，服务器响应的 header 中会用两个字段来表明：Expires 和 Cache-Control。

#### Expires

Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据，但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，现在大多数使用 Cache-Control 替代。

#### Cache-Control

Cache-Control 有很多的值可选，我们介绍一些常见的。

- no-store，不使用缓存，禁止缓存，多用于包含个人隐私数据或银行业务数据的响应
- no-cache，需要使用协商缓存来验证缓存数据
- private，只允许客户端缓存
- public，允许客户端和代理服务器缓存
- max-age=t，缓存内容将在 t 秒后失效

#### 协商缓存

所谓协商，就是向服务器发送请求时，服务器会根据请求头中的缓存标识来判断是否命中协商缓存，如果命中，返回 304 状态码，更新缓存标识然后通知浏览器从缓存中读取资源。

根据缓存标识，协商缓存可以分为两种方案。

#### Last-Modified

服务器在响应请求时，会

#### Etag
