---
title: HTTP
order: 3
---

# HTTP

HTTP 是基于 TCP/IP 的应用层协议，是 Web 上进行数据交换的基础，主要规定了客户端与服务器之间的通信格式，默认使用 80 端口。

## 发展历史

### HTTP/0.9

1991 年，第一个 HTTP 版本诞生，只有一个命令 `GET`，请求只有一个请求行，没有头部和实体，

```html
GET / index.html
```

响应只能是 HTML 格式的字符串，

```html
<html>
  <body>
    Hello World
  </body>
</html>
```

服务器发送完响应后，就会关闭 TCP 连接。

### HTTP/1.0

1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。

- 支持任意格式的内容传输，包括文字，图像、视频、二进制文件等
- 新增 POST，HEAD 命令丰富了浏览器与服务器的交互手段
- 请求和响应格式变更，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据
- 新增状态码（HTTP Status Code），多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

这个版本的 HTTP 已经可以满足大部分的交互需求，但是仍然存在以下缺点，

- 每个 TCP 连接只能发送一个请求。服务端发送数据完毕后，连接就关闭，如果还要请求其他资源，就必须再新建一个连接
- 性能较差，根本原因是 TCP 连接的新建成本很高（三次握手，慢启动机制），而且无法复用

### HTTP/1.1

为了解决上述问题，大约半年后，1997 年 1 月，HTTP/1.1 版本发布，它进一步完善了 HTTP 协议，一直用到了 20 多年后的今天，直到现在还是最流行的版本。HTTP/1.1 做了如下优化，

- 引入持久连接（persistent connection），实现了 TCP 连接复用。TCP 连接默认不关闭，不用显式地声明 Connection，可以被多个请求复用。
- 新增管道机制（pipelining），改进了 HTTP 协议的效率。支持一个 TCP 连接里，同时发送多个请求
- 新增分块传输编码，允许使用流模式发送块数据
- 新增 Host 字段，提供虚拟主机支持
- 支持更多的动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE

虽然这个版本允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，这会导致"队头堵塞"（Head-of-line blocking）问题。因为服务器只有处理完一个回应，才会进行下一个回应，要是前面的回应特别慢，后面就会有许多请求排队等着。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。显然如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。

### HTTP/2

2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

HTTP/2 基于谷歌开发的 SPDY 协议，解决 HTTP/1.1 效率不高等诸多问题。

- 引入新的编码机制，支持二进制传输
- 引入帧（frame）和流（stream）概念，解决队头阻塞问题，实现多路复用。一个 TCP 连接中允许存在多个流，也就是可以发送多个请求。
- 支持 Header 压缩
- 支持服务端推送

简单了解了 HTTP 的发展历史后，我们来深入看下当前最流行的 HTTP/1.1 和大幅提高 Web 性能的 HTTP/2。

## HTTP/1.1

### 请求格式

下面是一个 1.1 版本请求的例子。

```html
GET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent:
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */*
```

第一行是请求行，请求行必须在尾部添加协议版本，后面就是多行头信息，描述客户端的情况。下面是一个响应的例子。

```html
HTTP/1.1 200 OK Server: nginx/1.16.1 Date: Fri, 28 Aug 2020 06:09:58 GMT
Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996
15:55:28 GMT Transfer-Encoding: chunked Connection: keep-alive

<html>
  <body>
    Hello World
  </body>
</html>
```

响应格式为：**头信息 + 一个空行（\r\n） + 响应数据**。其中，头信息的第一行叫响应行，包括协议版本，状态码，状态描述。

### 常见状态码

#### 2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

#### 3XX 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

#### 4XX 客户端错误

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

#### 5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### Post 和 Get 区别

先引入副作用和幂等的概念。

副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

在技术上说：

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body 来传输比 Get 更多的数据，Get 没有这个技术
- URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

### HTTP 缓存

缓存可以减少网络 IO 消耗，提高访问速度，浏览器缓存是一种操作简单、效果显著的前端性能优化手段。

#### 缓存规则

缓存按类型可以分为：客户端缓存，服务端缓存，代理服务器缓存，HTTP 缓存属于客户端缓存。

按缓存规则，HTTP 缓存又分为：**强缓存和协商缓存**，优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

#### 强缓存

强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

强缓存命中时，返回的 HTTP 状态码为 200，

![image.png](https://i.loli.net/2020/09/11/mEgT9ociYQhrflO.png)

#### Expires

最初的强缓存实现方案是 exprires，当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段，

```js
expires: Wed, 11 Sep 2020 16:05:12 GMT
```

expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。

expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。

为了解决 expires 的问题，作为完全的替代方案，HTTP/1.1 新增了优先级更高的 Cache-Control 字段。

（PS：Cache-Control 可以视为 expires 的完全替代方案，在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容）

#### Cache-Control

Cache-Control 中，我们经常通过 max-age 来控制资源的有效期，

```js
cache-control: max-age=31536000
```

max-age 不是一个时间戳，而是一个时间长度。在上面的例子中，max-age 是 31536000 秒，它意味着该资源将在 31536000 秒以后失效，完美地规避了时间戳带来的潜在问题。

除了 max-age 外，Cache-Control 还有很多可选值，

```js
cache-control: max-age=3600, s-maxage=31536000
```

s-maxage 用于表示缓存服务器上（比如 cache CDN）的缓存的有效时间，只对 public 缓存有效，

它的优先级高于 max-age，两者同时出现时，优先考虑 s-maxage，也就是说，如果 s-maxage 未过期，则向代理服务器请求其缓存内容。

此外，针对资源能否被代理服务缓存，Cache-Control 提供了两个可选值，

- private，默认值，只能被浏览器缓存
- public，既可以被浏览器缓存，也可以被代理服务器缓存

这里的 private 是默认值，public 也不需要我们手动设置，因为其他明确的值（例如 “max-age”）已表示响应是可以缓存的。

**上面的可选值都是考虑需要对资源进行缓存的情况，能否设置资源不缓存呢？**

可以，Cache-Control 提供了 no-store 与 no-cache 两个可选值，其中，

no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。

no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

#### 协商缓存

协商缓存是浏览器与服务器合作之下的一种缓存策略。简单来说，就是向服务器发送请求时，服务器会根据请求头中的缓存标识来判断是否命中协商缓存，如果命中，返回 304 状态码，更新缓存标识然后通知浏览器从缓存中读取资源。

#### Last-Modified

最开始我们是通过 Last-Modified 这个缓存标识来实现协商缓存的，Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：

```js
Last-Modified: Fri, 27 Oct 2020 08:01:48 GMT
```

随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

```js
If-Modified-Since: Fri, 27 Oct 2020 08:01:48 GMT
```

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。

Last-Modified 也存在一些弊端，比如服务器无法正确地感知到文件的变化，考虑下面的两种场景：

- 编辑了文件，但文件的内容没有改变，此时服务端并不清楚我们是否真正改变了文件
- 修改文件的速度过快，比如 < 1000ms，由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的

为了解决上述问题，Etag 作为 Last-Modified 的补充方案出现了。

#### Etag

Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个例子，它可以是这样的：

```js
ETag: W / '2a3b-1602480f459';
```

那么下一次请求时，请求头里就会带上一个值相同的、名为 If-None-Match 的字符串供服务端比对了：

```js
If-None-Match: W/"2a3b-1602480f459"
```

Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。需要注意的是，Etag 并不能替代 Last-Modified，它只是作为 Last-Modified 的补充方案。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。

#### 缓存决策

实际面对一个具体的缓存需求时，可以参考 Chrome 官方给出决策流程图，

![image.png](https://i.loli.net/2020/09/11/kVAe4tYQN7yIBfi.png)

当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。

## HTTP/2.0

HTTP/2 协议的主要目的是提高网页性能。在 HTTP/1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

解决队头阻塞的方案是引入 **多路复用**，也叫 **多工（Multiplexing）**，实现多工的基础是二进制协议

### 二进制传输

HTTP/1.1 中，头信息是使用 ASCII 编码的文本，数据体可以是文本，也可以是二进制，HTTP/2 引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

所以 HTTP/2 是一个彻底的二进制协议，在二进制传输中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

![image.png](https://i.loli.net/2020/09/11/AIazWlXfbTM4x7Q.png)

（图片说明：HTTP/2.0 中的二级制传输示意）

### 多路复用

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，就可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

HTTP/2 定义了近十种帧，用于支持二进制的传输和解析，我们来看一下实现多路复用的一些细节。

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。HTTP/1.1 取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### Header 压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 服务端 Push

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

服务端推送的具体实现可以参考 [HTTP/2 服务器推送（Server Push）教程](https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)。
