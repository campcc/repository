---
title: 浏览器端优化初探
order: 7
---

## 内核

浏览器内核包含两部分：**渲染引擎（Layout Engine 或者 Rendering Engine）**和 **JS 引擎**。

早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。

目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。

虽然 Chrome 引擎已经迭代为 Blink，但是换汤不换药，Blink 也是基于 Webkit 衍生来的一个分支，接下来我们主要对业界霸主 Webkit 进行深度剖析。

## 渲染过程

简单来说，浏览器呈现网页的过程为，渲染引擎根据 HTML 文件描述构建相应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果。

其中，需要关注几个大模块，

- HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。
- CSS 解释器：解析 CSS 文档, 生成样式规则。
- 图层布局计算模块：布局计算每个对象的精确位置和大小。
- 视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。
- JavaScript 引擎：编译执行 Javascript 代码。

每一个页面的首次渲染都会经历下面的阶段（有可能是并行），

- 解析 HTML，发起页面渲染所需的各种外部资源请求(如果有)
- 计算样式，识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树
- 计算图层布局，页面中所有元素的相对位置信息，大小等信息均在这一步
- 绘制图层，根据 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码
- 整合图层，得到页面，浏览器会合并所有图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上

**几颗重要的树**

- DOM 树：解析 HTML 时创建的树，也叫 “内容树”。
- CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）时创建的树。CSSOM 的解析过程与 DOM 的解析过程是并行的。
- 渲染树：CSSOM 与 DOM 结合，之后得到的就是渲染树（Render tree ）。
- 布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，便得到了基于渲染树的布局渲染树（Layout of the render tree）。
- 绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。

## 基于渲染流程的 CSS 优化

**CSS 引擎的查找规则：从右到左的顺序匹配**

也就是说 **CSS 选择符是从右到左进行匹配的**。所以，以下代码的开销其实很高，

```css
#myList li {
  // some rule...
}
```

相当于浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList。

此外，通配符也很恐怖，

```
* {}
```

它会匹配所有元素，意味着浏览器必须去遍历每一个元素。

所以 CSS 优化我们一般会有以下的一些方案，

- 避免使用通配符
- 避免重复匹配重复定义，多关注可以通过继承实现的属性
- 少用标签选择器。如果可以，用类选择器替代
- 减少嵌套，后代选择器的开销是最高的，尽量将选择器的深度降到最低(一般不超过三层)

## CSS 与 JS 的加载顺序优化

HTML、CSS 和 JS，都具有阻塞渲染的特性。

HTML 阻塞，天经地义，没办法，因为我们得先有 DOM，主要考虑 CSS 和 JS 的阻塞问题。

**CSS 阻塞**

前面渲染过程介绍过，浏览器在构建 CSSOM 过程中，不会渲染任何内容，所以 DOM 会等待 CSSOM。因此，

**CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。**

具体一点，就是 `link`, `style` 标签往 `head` 里放，然后启用 CDN 实现静态资源加载速度的优化。其实这已经是内化的编码习惯了，这里我们了解其原理即可。

**JS 阻塞**

由于 JS 可能会修改 DOM 和 CSSOM，所以 JS 引擎和渲染进程是互斥的。因此 JS 会阻塞 CSSOM，如果不显式声明，也会阻塞 DOM。

这里的阻塞本质上就是：**JS 引擎抢走了渲染引擎的控制权**。

**JS 的三种加载方式**

- 正常模式，无 async, defer：阻塞渲染，必须等 JS 解析完成，渲染才能继续
- async 模式：解析到 script 标签时，会先异步加载 JS，加载完成后立即执行
- defer 模式：也是异步加载，但是执行会推迟，等整个文档解析完成、DOMContentLoaded 事件即将被触发时，依次执行

所以一般来说，当我们的脚本与 DOM 元素和其他脚本关系不大时，用 async，脚本依赖 DOM 元素和其他脚本时，用 defer。
