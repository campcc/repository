---
title: SSR
order: 6
---

## 服务端渲染的运行机制

**客户端渲染**

了解服务端渲染前，我们先来看下与之对应的客户端渲染。

客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，往往是这个德行：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>我是客户端渲染的页面</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="index.js"></script>
  </body>
</html>
```

根节点下到底是什么内容呢？你不知道，我不知道，只有浏览器把 index.js 跑过一遍后才知道，这就是典型的客户端渲染。

**页面上呈现的内容，你在 html 源文件里里找不到**——这正是它的特点。

**服务端渲染**

服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。也就是我们说的 “所见即所得”，比如知乎就是典型的服务端渲染案例。

**页面上呈现的内容，我们在 html 源文件里也能找到。**

## 解决了什么问题

**SEO**

客户端渲染模式下，不利于搜索引擎搜索关键字，搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。

**首屏加载**

客户端渲染模式下，需要解析 JS，导致首屏加载速度过慢。

## 实现原理

在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。

本质上就是 “把 JS 在服务器上先跑一遍”，只不过现在是 “把 Vue、React 等框架代码先在 Node 上跑一遍”。

1. Virtual DOM 扔给 Node 服务器
2. renderToString 将虚拟 DOM 转化为真实 DOM
3. 编写模板，塞入 DOM，返回

## 应用场景

服务端渲染并非万全之策，在这个网民遍地的时代，几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。

首屏渲染体验和 SEO 的优化方案也有很多，建议先考虑其他方案，所有的招式都用完了，性能表现还是不尽人意时，再考虑服务端渲染。
