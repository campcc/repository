---
title: 重绘和回流
order: 10
---

## 重绘与回流

我们再来复习一遍什么是重绘和回流。

**重绘**

当我们对 DOM 的修改引发了元素样式的变化，如修改颜色和背景色时，浏览器需要重新为该元素绘制样式，这个过程就叫重绘。

**回流**

当我们对 DOM 的修改引发了元素几何尺寸的变化，如修改宽高，隐藏元素时，浏览器需要重新计算元素的几何属性，其他元素的几何属性和位置也会受到影响，然后将计算结果重新绘制出来。这个过程就是回流(重排)。

## 哪些操作会导致重绘与回流

**重绘**

不触发回流，但又触发了样式改变的 DOM 操作，比如：修改背景色、文字色、visibility 可见性等

**回流**

**最“贵”的操作，改变 DOM 元素的几何属性**

这个改变几乎可以说是“牵一发动全身”——当一个 DOM 元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。

常见的几何属性有：width、height、padding、margin、left、top、border 等。

**“价格适中”的操作，改变 DOM 树的结构**

这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。

**最容易被忽略的操作：获取一些特定属性的值**

当我们要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，也会触发回流，为什么？

因为这些值有一个**共性**，就是需要通过**即时计算**得到。因此浏览器为了获取这些值，也会进行回流。

除此之外，当我们调用了 `getComputedStyle` 方法，或者 IE 里的 `currentStyle` 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。

## 如何尽量避免重绘与回流

**能缓存的就缓存，使用 JS 缓存计算结果，避免频繁改动**

**避免逐条改变样式，使用类名去合并样式**

**DOM 离线**

这是一个比较经典的优化手段，回流和重绘，都是在“该元素位于页面上”的前提下会发生的，一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。

## Flush 队列

现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。

**“不得已”时刻**

形如访问即时属性，计算属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队，这就是所谓的“不得已”时刻。
