---
title: 图片优化
order: 3
---

## 图片优化真的必要吗

接着上篇的网络层优化，我们知道图片请求也是 HTTP 请求的一部分，那么图片优化真的必要吗？

《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 [博客](http://www.stevesouders.com/blog/2013/04/26/i/) 中提到：

> 我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。几个月后，我意识到这是错误的。图片才是页面上最重要的部分。我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。

这段话可谓字字珠玑。此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。

图片优化，就是压缩图片的体积，或者一开始就选取体积较小的图片格式，压缩以牺牲一部分成像质量为代价的，所以优化的本质其实是权衡。

## 图片格式

时下应用较为广泛的 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等，此外，老生常谈的雪碧图（CSS Sprites）仍在一线应用中发光发热。

### 二进制位数与色彩的关系

在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。

一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。

下面我们先了解一些常见的图片格式。

### JPG/JPEG

JPG 最大的特点是有损压缩，即使被称为“有损”压缩，JPG 的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉。

**优点：体积小、加载快**

因此，JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。比如淘宝，京东页面醒目的，最庞大的图片，都是以 JPG。

使用 JPG 做大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。

**缺陷：有损压缩，不支持透明**

使用 JPG 处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显，而且不支持透明。

### PNG

PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。根据二进制数的位数不同，分为 PNG-8，PNG-24。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。

我们一般用 PNG 来呈现小的 Logo、颜色简单且对比强烈的图片或背景等，比如淘宝的 LOGO。

**优缺点：无损压缩、质量高、体积大、支持透明**。

### SVG

SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。

SVG 是文本文件，我们可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分。

**优缺点：文本文件、体积小、不失真、兼容性好**

### Base64

Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。在了解 Base64 之前，我们先来了解一下雪碧图。

“雪碧图、CSS 精灵、CSS Sprites、图像精灵”，这些可爱的名字描述的都是她，一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。

和雪碧图一样，Base64 图片的出现，也是为了 **减少加载网页图片时对服务器的请求次数，从而提升网页性能**。

**Base64 是作为雪碧图的补充而存在的**。

与雪碧图不同，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。但是 Base64 编码后，图片大小会膨胀为原文件的 4/3，所以它常用于非常小的 Logo，比如掘金 LOGO。

一般来说，考虑一张图片满足以下场景时，我们会对其进行 Base64 编码，我们可以直接将编码结果写入

- 图片的实际尺寸很小(2kb 以内)
- 图片无法以雪碧图的形式与其他小图结合(合并雪碧图仍然是我们减少 HTTP 请求的主要途径，Base64 是对雪碧图的补充)
- 图片的更新频率非常低(不需要我们重复编码和修改文件内容，维护成本较低)

此外，针对 Base64 编码工具，推荐使用 webpack 的 url-loader 来进行转码。它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。

### WebP

WebP 可以像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片，简单来说，它是全能型选手。

WebP 唯一的缺点就是太年轻，年轻意为着什么？逃不过浏览器兼容的大坑，让人望而却步。

但是限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题。

具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等其他浏览器下它无法显示的问题，也就是说我们需要准备 PlanB，准备降级方案。

以淘宝首页为例，我们发现其实也有 WebP 关键字，

```html
<img
  src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp"
  alt="手机app - 聚划算"
  class="app-icon"
/>
```

大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。

没错，优雅的降级处理。站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。

此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。这样一来，浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。
